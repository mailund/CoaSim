<?xml version="1.0" encoding="ISO-8859-1" ?>
<?xml-stylesheet type="text/xsl" href="guile-bindings.xsl"?>

<guile-bindings>


<method name="interval-start">
  <brief>Returns the start position of an interval.</brief>
  <prototype>(interval-start interval)</prototype>
  <example>(define p (arg-parameters rho Q G beta))
(define markers (make-random-snp-markers 10 0.1 0.9))
(define intervals (let ((arg (simulate p markers 100))) (intervals arg)))
(map interval-start intervals)</example>
  <description>
    <p>
     Returns the start position of an interval.
    </p>
  </description>
</method>


<method name="interval-end">
  <brief>Returns the end position of an interval.</brief>
  <prototype>(interval-end interval)</prototype>
  <example>(define markers (make-random-snp-markers 10 0.1 0.9))
(define intervals (let ((arg (simulate markers 100 :rho 400))) (intervals arg)))
(map interval-end intervals)</example>
  <description>
    <p>
     Returns the end position of an interval.
    </p>
  </description>
</method>


<method name="total-branch-length">
  <brief>Returns the total tree branch length of the local tree of an interval.</brief>
  <prototype>(total-branch-length interval-or-tree)</prototype>
  <example>  (use-modules (coasim rand))
 (define markers (make-random-snp-markers 10 0.1 0.9))
 (define intervals (intervals (simulate markers 100 :rho 400)))
 (map total-branch-length intervals)</example>
  <description>
    <p>
     Returns the total tree branch length of the local tree of an interval.
     The argument to the function can be either a local interval, as returned
     by the intervals function, or a local tree, as returned by the local-trees
     function.
    </p>
  </description>
</method>


<method name="tree-height">
  <brief>Returns the height of the local tree of an interval.</brief>
  <prototype>(tree-height interval-or-tree)</prototype>
  <example> (use-modules (coasim rand))
 (define markers (make-random-snp-markers 10 0.1 0.9))
 (define intervals (local-trees (simulate markers 100 :rho 400)))
 (map tree-height intervals)</example>
  <description>
    <p>
     Returns the height of the local tree of an interval.
     The argument to the function can be either a local interval, as returned
     by the intervals function, or a local tree, as returned by the local-trees
     function.
    </p>
  </description>
</method>


<method name="interval->tree">
  <brief>Returns tree local to an interval.</brief>
  <prototype>(interval->tree interval)</prototype>
  <example>(define markers (make-random-snp-markers 10 0.1 0.9))
(define intervals (let ((arg (simulate markers 100 :rho 400))) (intervals arg)))
(define trees (map interval->tree intervals)) </example>
  <description>
    <p>Returns the tree local to an interval.</p>
  </description>
</method>


<method name="tree->interval">
  <brief>Returns interval a local tree covers.</brief>
  <prototype>(tree->interval tree)</prototype>
  <example>(define markers (make-random-snp-markers 10 0.1 0.9))
(define intervals (let ((arg (simulate markers 100 :rho 400))) (intervals arg)))
(define trees (map interval->tree intervals)) 
(define intervals2 (map tree->interval trees))</example>
  <description>
    <p>
      Returns interval a local tree covers.  The function is the reverse
      of interval->tree.
    </p>
  </description>
</method>



<method name="trait-marker">
  <brief>Creates a trait marker on the simulated region.</brief>
  <prototype>(trait-marker position low-freq high-freq)</prototype>
  <example>(trait-marker 0.5 0.18 0.22)</example>
  <description>
    <p>
      Creates a trait marker on the simulated region.  The first
      parameter determines the position (between 0 and 1) along the
      region, the second the lowest frequency accepted for the
      mutation type, and the third the highest frequency accepted for the
      mutation type.
    </p>
  </description>
</method>


<method name="snp-marker">
  <brief>Creates a SNP marker on the simulated region.</brief>
  <prototype>(snp-marker position low-freq high-freq)</prototype>
  <example>(snp-marker 0.5 0.1 0.9)</example>
  <description>
    <p>
      Creates a SNP marker on the simulated region.  The first
      parameter determines the position (between 0 and 1) along the
      region, the second the lowest frequency accepted for the
      mutation type, and the third the highest frequency accepted for the
      mutation type.
    </p>
  </description>
</method>


<method name="ms-marker">
  <brief>Creates a micro-satellite marker on the simulated region.</brief>
  <prototype>(ms-marker position theta K)</prototype>
  <example>(ms-marker 0.5 0.2 10)</example>
  <description>
    <p>
      Creates a micro-satellite marker on the simulated region.  The
      first parameter determines the position (between 0 and 1) along
      the region, the second the mutation rate of the marker, and the
      third the size of the alphabet for the marker (in the K allele
      model).
    </p>
  </description>
</method>


<method name="trait-marker?">
  <brief>A predicate that evalutes to true for trait markers only.</brief>
  <prototype>(trait-marker? marker)</prototype>
  <example>(trait-marker? marker)</example>
  <description>
    <p>
     A predicate that evalutes to true for trait markers and false for
     all other types.
    </p>
  </description>
</method>


<method name="snp-marker?">
  <brief>A predicate that evalutes to true for SNP markers only.</brief>
  <prototype>(snp-marker? marker)</prototype>
  <example>(snp-marker? marker)</example>
  <description>
    <p>
     A predicate that evalutes to true for SNP markers and false for
     all other types.
    </p>
  </description>
</method>


<method name="ms-marker?">
  <brief>A predicate that evalutes to true for micro-satellite markers only.</brief>
  <prototype>(ms-marker? marker)</prototype>
  <example>(ms-marker? marker)</example>
  <description>
    <p>
     A predicate that evalutes to true for micro-satellite  markers and false
     for all other types.
    </p>
  </description>
</method>


<method name="position">
  <brief>Returns the position of a marker.</brief>
  <prototype>(position marker)</prototype>
  <example>(position marker)</example>
  <description>
    <p>Returns the position of a marker.
    </p>
  </description>
</method>




<method name="event-time">
  <brief>Returns the time of the event represented by a node.</brief>
  <prototype>(event-time node)</prototype>
  <example>(define coa-times '())
(define (coa-cb n k) (set! coa-times (cons (event-time n) coa-times)))
(define rc-times '())
(define (rc-cb n1 n2) (set! rc-times (cons (event-time n1) rc-times)))
(simulate markers no-leaves :rho 400
	  :coalescence-callback   coa-cb 
	  :recombination-callback rc-cb) </example>
  <description>
    <p>Returns the time of the event represented by a node.
    </p>
  </description>
</method>


<method name="recombination-point">
  <brief>Returns the recombination point of a recombination node.</brief>
  <prototype>(recombination-point recombination-node)</prototype>
  <example>(define rc-points '())
(define (rc-cb n1 n2 k) (set! rc-points (cons (recombination-point n1) rc-points)))
(simulate markers no-leaves :rho 400 :recombination-callback rc-cb) </example>
  <description>
    <p>
      Returns the recombination point of a recombination node.
    </p>
  </description>
</method>


<method name="gene-conversion-start">
  <brief>Returns the start point of a gene conversion.</brief>
  <prototype>(gene-conversion-start gene-conversion-node)</prototype>
  <example>(define gc-start '())
(define (gc-cb n1 n2 k) (set! gc-start (cons (gene-conversion-start n1) gc-start)))
(simulate markers no-leaves :gamma 10 :Q 0.2 :geneconversion-callback gc-cb) </example>
  <description>
    <p>
      Returns the start point of a gene conversion.
    </p>
  </description>
</method>


<method name="gene-conversion-end">
  <brief>Returns the end point of a gene conversion.</brief>
  <prototype>(gene-conversion-end gene-conversion-node)</prototype>
  <example>(define gc-end '())
(define (gc-cb n1 n2 k) (set! gc-end (cons (gene-conversion-end n1) gc-end)))
(simulate markers no-leaves :gamma 10 :Q 0.2 :geneconversion-callback gc-cb) </example>
  <description>
    <p>
      Returns the end point of a gene conversion.
    </p>
  </description>
</method>




<method name="simulate">
  <brief>Simulate an ARG and corresponding sequences.</brief>
  <prototype>(simulate marker-list no-leaves . additional-keyword-parameters)</prototype>
  <example>(define markers (make-random-snp-markers 10 0.1 0.9))
(define arg (simulate markers 100 :rho 400 :beta 10))

(define coa-times '())
(define (coa-cb n k) (set! coa-times (cons (event-time n) coa-times)))
(simulate markers 10 :coalescence-callback coa-cb :rho 400 :beta 10)
(display "coalescence times:\n")
(map (lambda (t) (display t)(newline)) coa-times)
(newline)</example>
  <description>
    <p>
      Simulate an ARG and corresponding sequences, based ARG parameters, 
      a list of markers, and the number of markers to simulate.
    </p>
    <p>
      The building of the ARG is affected by the following paramters, that 
      can be set using keyword arguments:
    </p>
    <ul>
      <li><b>rho:</b> the <em>scaled recombination rate</em>, rho=4Nr.  See 
        e.g. <em>Hein, Schierup and Wiuf:</em> Gene Genealogies, Variation
        and Evolution, section 5.5 for details.
	By default, this parameter is 0.
      </li>
      <li><b>gamma:</b> the <em>scaled gene-conversion rate</em>, gamma=4Ng.
        See e.g. <em>Hein, et al.:</em> section 5.10 for details.
	By default, this parameter is 0.
      </li>
      <li><b>Q:</b> the <em>gene-conversion tract length intensity</em>.
        See e.g. <em>Hein, et al.:</em> section 5.10 for details.
	By default, this parameter is 0.
      </li>
      <li><b>beta:</b> the <em>exponential growth rate</em>, beta=2Nb.
        See e.g. <em>Hein, et al.:</em> section 4.3 for details.
	By default, this parameter is 0.
      </li>
    </ul>
    <p>
      For fine-monitoring of the simulation, callback functions can be given
      as key-word arguments.  The supported callbacks are:
    </p>
    <ul>
      <li><b>coalescence-callback:</b>
        called with the single node that is the result of a coalescent event,
        and the number of lineages at the time of the coalescent (i.e.
        the number of linages just after the event, moving forward in time).
      </li>
      <li><b>recombination-callback:</b>
          called with the two nodes that is the result of a recombination
          event, and the number of lineages at the time of the recombination
	  (i.e. the number of linages just after the event, moving forward 
	  in time).
      </li>
      <li><b>geneconversion-callback:</b>
          called with the two nodes that is the result of a gene conversion
          event, and the number of lineages at the time of the gene conversion
	  (i.e. the number of linages just after the event, moving forward 
	  in time).
      </li>
    </ul>
    <p>
      The following additional keyword arguments are available:
    </p>
    <ul>
      <li><b>keep-empty-intervals:</b> Turns off an optimisation that 
          removes intervals not containing markers from the ARG simulation.
          This option is useful when the simulation is concerned with ARG
          properties rather than just the resulting sequences.
      </li>
      <li><b>random-seed:</b> an integer used as random seed for the
          simulation.  In most cases, this argument will not be used, but
          it is useful for regression testing of scheme modules for CoaSim.
      </li>
    </ul>
  </description>
</method>


<method name="sequences">
  <brief>Returns the simulated sequences of an ARG as a list of lists.</brief>
  <prototype>(sequences arg)</prototype>
  <example>(define markers (make-random-snp-markers 10 0.1 0.9))
(define haplotypes (let ((arg (simulate markers 100 :rho 400))) (sequences arg)))</example>
  <description>
    <p>Returns the simulated sequences of an ARG as a list of lists.
    </p>
  </description>
</method>


<method name="intervals">
  <brief>Returns the intervals sharing genealogy in the ARG as a list.</brief>
  <prototype>(intervals arg)</prototype>
  <example>(define markers (make-random-snp-markers 10 0.1 0.9))
(define intervals (let ((arg (simulate markers 100 :rho 400))) (intervals arg)))</example>
  <description>
    <p>
     Returns the intervals sharing genealogy in the ARG as a list.
     Only intervals containing markers are returned.
    </p>
  </description>
</method>

<method name="local-trees">
  <brief>Returns the local trees, i.e. the trees for intervals sharing genealogy in the ARG as a list.</brief>
  <prototype>(local-trees arg)</prototype>
  <example>(define p (arg-parameters rho Q G beta))
(define markers (make-random-snp-markers 10 0.1 0.9))
(define trees (let ((arg (simulate markers 100 :rho 400))) (local-trees arg)))</example>
  <description>
    <p>
     Returns the local trees, i.e. the trees for 
     intervals sharing genealogy in the ARG as a list.
     Only trees containing markers are returned.
    </p>
  </description>
</method>



<method name="no-recombinations">
  <brief>Returns the number of recombinations in the ARG.</brief>
  <prototype>(no-recombinations arg)</prototype>
  <example>(define markers (make-random-snp-markers 10 0.1 0.9))
(define arg (simulate markers 100 :rho 400))
(define n (no-recombinations arg))</example>
  <description>
    <p>
     Returns the number of recombinations in the ARG.
    </p>
  </description>
</method>


<method name="no-coalescence-events">
  <brief>Returns the number of coalescence events in the ARG.</brief>
  <prototype>(no-coalescence-events arg)</prototype>
  <example>(define markers (make-random-snp-markers 10 0.1 0.9))
(define arg (simulate markers 100 :rho 400))
(define n (no-coalescence-events arg))</example>
  <description>
    <p>
     Returns the number of coalescence events in the ARG.
    </p>
  </description>
</method>


<method name="no-gene-conversions">
  <brief>Returns the number of gene conversions in the ARG.</brief>
  <prototype>(no-gene-conversions arg)</prototype>
  <example>(define markers (make-random-snp-markers 10 0.1 0.9))
(define arg (simulate markers 100 :gamma 10 :Q 0.2))
(define n (no-gene-conversions arg))</example>
  <description>
    <p>
     Returns the number of gene conversions in the ARG.
    </p>
  </description>
</method>

       
<method name="simulate-sequences">
  <brief>Simulate a list of sequences.</brief>
  <prototype>(simulate-sequences markers no-leaves . additional-simulation-parameters)</prototype>
  <example>(define markers (make-random-snp-markers 10 0 1))
(define seqs (simulate-sequences markers 10 :rho 400))</example>
  <description>
    <p>
     Simulate a list of sequences.  This function is just a short-cut
     for `simulate' followed by `sequences': 
    </p>
    <code><pre> (define (simulate-sequences . args)
   (sequences (apply simulate args)))</pre></code>
  </description>
</method>




 <module name="(coasim SNP haplotypes)">
  <brief>
    This module contains functions for manipulating SNP haplotypes.
  </brief>

   <method name='split-in-cases-controls'>
    <brief>Split a list of haplotypes into cases and controls.</brief>
    <prototype>(split-in-cases-controls haplotypes trait-idx)</prototype>
    <example> (define haplotypes (simulate-sequences markers 100))
 (define cases-and-controls (split-in-cases-controls haplotypes trait-idx))
 (define cases    (car  cases-and-controls))
 (define controls (cadr cases-and-controls))</example>
    <description>
     <p>
      Split a dataset into cases and controls, based on the value at
      trait-idx.   The following keyword arguments can be used to control
      the split:
     </p>
     <ul>
       <li><b>mutant-prob:</b> The probability that a mutant (allele 1) is 
           considered a case.  By default this is 1.
       </li>
       <li><b>wild-type-prob:</b> The probability that a wild-type (allele 0) 
           is considered a case.  By default this is 0.
       </li>
     </ul>
    </description>
   </method>
 </module>


 <module name="(coasim SNP genotypes)">
  <brief>
    This module contains functions for manipulating SNP (unphased) genotypes.
  </brief>

   <method name='haplotypes->genotypes'>
    <brief>Translate a list of SNP haplotypes into a list of SNP genotypes.</brief>
    <prototype> (haplotypes->genotypes haplotype-list)</prototype>
    <example> (use-modules (coasim rand) (coasim SNP genotypes))
 (define haplotypes (simulate-sequences (make-random-snp-markers 4 0 1) 8))
 (display haplotypes)(newline)
 (define genotypes (haplotypes->genotypes haplotypes))
 (display genotypes)(newline) </example>
    <description>
     <p>
      Translate a list containing an even number of SNP haplotypes
      into a list of SNP genotypes.  The haplotypes are paired and the
      alleles are translated such that homozygote 00 becomes 0, homozygote
      11 becomes 1, and heterozygotes become 2.
     </p>
    </description>
   </method>
   <method name='split-in-cases-controls'>
    <brief>Split a list of genotypes into cases and controls.</brief>
    <prototype>(split-in-cases-controls genotypes trait-idx)</prototype>
    <example> (define haplotypes (simulate-sequences markers 100))
 (define genotypes (haplotypes->genotypes haplotypes))
 (define cases-and-controls (split-in-cases-controls genotypes trait-idx
                                                     :disease-model 'recessive))
 (define cases    (car  cases-and-controls))
 (define controls (cadr cases-and-controls))</example>
    <description>
     <p>
      Split a dataset into cases and controls, based on the value at
      trait-idx.   The following keyword arguments can be used to control
      the split:
     </p>
     <ul>
       <li><b>homozygote-0-prob:</b> The probability that genotype 0 (or 00)
           is considered a case.  By default this is 0.
       </li>
       <li><b>homozygote-1-prob:</b> The probability that genotype 1 (or 11)
           is considered a case.  By default this is 1.
       </li>
       <li><b>heterozygote-prob:</b> The probability that genotype 2 (01 or 10)
           is considered a case.  By default this is 0.5.
       </li>
       <li><b>disase-model:</b> Should be either 'recessive or 'dominant;
           if 'dominant genotypes 1 (11) and 2 (01 or 10) are considered cases,
           if 'recessive only genotypes 1 (11) are considered cases.
           only 
       </li>
     </ul>
    </description>
   </method>
 </module>


 <module name="(coasim batch)">
  <brief>
    This module contains functions for running batchs of simulations.
    Although most of the functionallity in this module can be easily 
    implemented using Scheme's control-flow structures, the functions here
    make batch running just a tad simpler.
  </brief>

 <method name='repeat'>
  <brief>Call a block of code a certain number of times.</brief>
  <prototype>(repeat n c)</prototype>
  <example> (use-modules (coasim batch))
 (repeat 20
  (let* ((m (snp-marker 0.5 0 1))
         (arg (simulate (list m) 10 :random-seed 10))
         (tree (car (local-trees arg))))
    (display tree)))
 (newline) </example>
  <description>
   <p>
    Execute the code `c' `n' number of times.
   </p>
  </description>
 </method>
 <method name='repeat-while'>
  <brief>Call a block of code until a predicate evaluates to false.</brief>
  <prototype>(repeat-while p c)</prototype>
  <example> (use-modules (ice-9 format) (coasim batch))

 (repeat-while (lambda (branch-length) (&lt; branch-length 5))
  (let* ((m (snp-marker 0.5 0 1))
         (arg (simulate (list m) 10))
         (tree (car (local-trees arg)))
         (branch-length (total-branch-length tree)))
    (format #t "~4f " branch-length)
    branch-length))
 (newline)</example>
  <description>
   <p> Execute the code `c' until the predicate `p', evaluated on
    the result of `c' evaluates to false. 
   </p>
  </description>
 </method>
 <method name='repeat-with-index'>
  <brief>Call a block of code a certain number of times.</brief>
  <prototype> (repeat-with-index (i n) c)
 (repeat-with-index (i start stop) c)
 (repeat-with-index (i start stop step) c) </prototype>
  <example> (use-modules (coasim batch))
 (repeat-with-index (i 10)
    (let* ((markers (make-random-snp-markers 10 0 1))
           (seqs (simulate-sequences markers 10))
           (pos-file (string-append "positions." (number->string i) ".txt"))
           (seq-file (string-append "sequences." (number->string i) ".txt")))
      (call-with-output-file pos-file (marker-positions-printer markers))
      (call-with-output-file seq-file (sequences-printer seqs))))
 
 (repeat-with-index (i 2 12)
    (let* ((markers (make-random-snp-markers 10 0 1))
           (seqs (simulate-sequences markers 10))
           (pos-file (string-append "positions." (number->string i) ".txt"))
           (seq-file (string-append "sequences." (number->string i) ".txt")))
      (call-with-output-file pos-file (marker-positions-printer markers))
      (call-with-output-file seq-file (sequences-printer seqs))))
 
 (repeat-with-index (i 2 20 2)
    (let* ((markers (make-random-snp-markers 10 0 1))
           (seqs (simulate-sequences markers 10))
           (pos-file (string-append "positions." (number->string i) ".txt"))
           (seq-file (string-append "sequences." (number->string i) ".txt")))
      (call-with-output-file pos-file (marker-positions-printer markers))
      (call-with-output-file seq-file (sequences-printer seqs)))) </example>
  <description>
   <p> Execute the code `c' a number of times, making the index
    variable `i' visible to the code in `c'.  Comes in three
    variants, a simple iteration from 1 to `n', an iteration from
    `start' to `stop', and an iteration from `start' to `stop' in
    jumps of `step'.
   </p>
  </description>
 </method>
 <method name='tabulate'>
  <brief>Call a block of code a certain number of times, collecting
         the results in a list.</brief>
  <prototype> (tabulate n c)</prototype>
  <example> (use-modules (coasim batch))
 (let* ((no-iterations 10000)
        (branch-lengths
         (tabulate no-iterations
          (let* ((m (snp-marker 0.5 0 1))
                 (arg (simulate (list m) 10))
                 (tree (car (local-trees arg)))
                 (branch-length (total-branch-length tree)))
            branch-length))))
   (display (/ (apply + branch-lengths) no-iterations))(newline)) </example>
  <description>
   <p>Execute the code `c' `n' number of times, collecting the
    results of evaluating `c' in a list that is returned as the
    result of the tabulation.
   </p>
  </description>
 </method>
 <method name='fold'>
  <brief>
   Call a block of code a certain number of times, collecting the result
   using a combination function.
  </brief>
  <prototype>(fold n comb init code)</prototype>
  <example> (let* ((no-iterations 10000)
        (branch-sum
         (fold no-iterations (lambda (val sum) (+ val sum)) 0
          (let* ((m (snp-marker 0.5 0 1))
                 (arg (simulate (list m) 10))
                 (tree (car (local-trees arg)))
                 (branch-length (total-branch-length tree)))
            branch-length))))
   (display (/ branch-sum no-iterations))(newline))</example>
  <description> <p> Execute the code `code' `n' number of times,
   combining the result of `code' using the `comb' function.  The
   `comb' is called with two arguments in each iteration, the first
   is the result of having run `code', the second is the result of
   the previous combination, initially the value `init' passed to
   `fold'.  </p>
  </description>
 </method>
 </module>


 <module name="(coasim rand)">
  <brief>
    This module contains functions making random marker configurations.
  </brief>


 <method name='make-random-trait-markers'>
  <brief>Make a list of random trait markers.</brief>
  <prototype>(make-random-trait-markers no-markers low-freq high-freq)</prototype>
  <example>(define disease-marker (car (make-random-trait-markers 1 0.18 0.22)))</example>
  <description>
   <p>
    Make a list of random positioned trait markers.  The low and 
    high frequency constraints are similar to the `trait-marker'
    function.
   </p>
  </description>
 </method>

 <method name='make-random-snp-markers'>
  <brief>Make a list of random SNP markers.</brief>
  <prototype>(make-random-snp-markers no-markers low-freq high-freq)</prototype>
  <example>(define snp-markers (make-random-snp-markers 10 0.1 0.9))</example>
  <description>
   <p>
    Make a list of random positioned SNP markers.  The low and 
    high frequency constraints are similar to the `snp-marker'
    function.
   </p>
  </description>
 </method>

 <method name='make-random-ms-markers'>
  <brief>Make a list of random micro-satellite markers.</brief>
  <prototype>(make-random-ms-markers no-markers theta K)</prototype>
  <example>(define snp-markers (make-random-ms-markers 10 0.1 15))</example>
  <description>
   <p>
    Make a list of random positioned micro-satellite markers.
    The theta and K parameters are similar to the `ms-marker'
    function.
   </p>
  </description>
 </method>

 </module>


 <module name="(coasim markers)">
  <brief>
    This module contains functions manipulating sorted lists of markers.
  </brief>

   <method name='sort-markers'>
    <brief>Sort a list of markers.</brief>
    <prototype>(sort-markers marker-list)</prototype>
    <example>(sort-markers marker-list)</example>
    <description>
     <p>
      Sort a list of markers with relation to their position.
     </p>
    </description>
   </method>
   <method name='insert-sorted-idx'>
    <brief>Inserts a marker in a sorted list of markers..</brief>
    <prototype>(insert-sorted-idx marker-list marker)</prototype>
    <example> (define snp-markers (make-random-snp-markers 10 0.1 0.9))
 (define disease-marker (car (make-random-trait-markers 1 0.18 0.22)))
 (define markers-and-index (insert-sorted-idx snp-markers disease-marker))</example>
    <description>
     <p>
      This function inserts a marker into a sorted list of markers and
      return a list who's first element is the resulting list and who's
      second element is the index the marker got in the new list.
     </p>
    </description>
   </method>
   <method name='insert-sorted'>
    <brief>Inserts a marker in a sorted list of markers.</brief>
    <prototype>(insert-sorted sorted-marker-list marker)</prototype>
    <example>(insert-sorted sorted-marker-list marker)</example>
    <description>
     <p>
      This function inserts a marker into a sorted list of markers and
      return the resulting list.
     </p>
    </description>
   </method>
   <method name='merge-markers'>
    <brief>Merge two or more lists of sorted markers.</brief>
    <prototype>(merge-markers . list-of-marker-lists)</prototype>
    <example>(merge-markers marker-list-1 marker-list-2 marker-list-3)</example>
    <description>
     <p>
      Merge two or more lists of sorted markers.
     </p>
    </description>
   </method>
   <method name='split-in-cases-controls'>
    <brief>Split a list of sequences into cases and controls.</brief>
    <prototype>(split-in-cases-controls sequences trait-idx is-case?)</prototype>
    <example>(use-modules (coasim markers))
    (let ((is-case? (lambda (h) (= 1 (list-ref h trait-idx)))))
        (split-in-cases-controls seqs trait-idx is-case?)))</example>
    <description>
     <p>
      Split a dataset into cases and controls, based on the value at
      trait-idx.  If the value at that index satisfy the is-case? predicate,
      the sequence is considered a case, otherwise a control.
     </p>
    </description>
   </method>
 </module>


 <module name="(coasim io)">
  <brief>
    This module contains functions for reading and writing coasim data.
  </brief>

   <method name='print-sequences'>
    <brief>Print a list of sequences.</brief>
    <prototype>(print-sequences port sequences)</prototype>
    <example>(print-sequences (current-output-port) sequences)</example>
    <description>
     <p>
      This function prints the sequences in the list `sequences' to
      the output port `port'.
     </p>
    </description>
   </method>
   <method name='print-positions'>
    <brief>Print a list of positions.</brief>
    <prototype>(print-positions port positions)</prototype>
    <example>(print-positions (current-output-port) positions)</example>
    <description>
     <p>
      This function prints the positions (numbers) in the list `positions' to
      the output port `port'.
     </p>
    </description>
   </method>
   <method name='print-marker-positions'>
    <brief>Print a list of positions from markers.</brief>
    <prototype>(print-marker-positions port markers)</prototype>
    <example>(print-marker-positions (current-output-port) markers)</example>
    <description>
     <p>
      This function prints the positions of the markers in the list `markers'
      to the output port `port'.
     </p>
    </description>
   </method>

 <method name='sequences-printer'>
  <brief>Convenience function for printing sequences.</brief>
  <prototype>(sequences-printer sequences)</prototype>
  <example>(call-with-output-file "sequences.txt" (sequences-printer sequences))</example>
  <description>
   <p>
    A convenience function, based on `print-sequences', that, given a 
    list of sequences, gives a function with one argument, a port, that
    when applied writes the sequences to the port.
   </p>
   <p>
    The function is useful for calls to `call-with-output-file'.
   </p>
  </description>
 </method>

 <method name='sequences-port'>
  <brief>Convenience function for printing sequences.</brief>
  <prototype>(sequences-port port)</prototype>
  <example>(map (sequence-port port) list-of-sequences)</example>
  <description>
   <p>
    A convenience function, based on `print-sequences', that, given a 
    list a port, gives a function with one argument, a sequence, that
    when applied writes the sequences to the port.
   </p>
   <p>
    The function is useful for mapping over lists of sequences.
   </p>
  </description>
 </method>



 <method name='positions-printer'>
  <brief>Convenience function for printing positions.</brief>
  <prototype>(positions-printer positions)</prototype>
  <example>(call-with-output-file "positions.txt" (positions-printer positions))</example>
  <description>
   <p>
    A convenience function, based on `print-positions', that, given a 
    list of positions, gives a function with one argument, a port, that
    when applied writes the positions to the port.
   </p>
   <p>
    The function is useful for calls to `call-with-output-file'.
   </p>
  </description>
 </method>

 <method name='positions-port'>
  <brief>Convenience function for printing positions.</brief>
  <prototype>(positions-port port)</prototype>
  <example>(map (position-port port) list-of-positions)</example>
  <description>
   <p>
    A convenience function, based on `print-positions', that, given a 
    list a port, gives a function with one argument, a position, that
    when applied writes the positions to the port.
   </p>
   <p>
    The function is useful for mapping over lists of positions.
   </p>
  </description>
 </method>



 <method name='marker-positions-printer'>
  <brief>Convenience function for printing marker-positions.</brief>
  <prototype>(marker-positions-printer marker-positions)</prototype>
  <example>(call-with-output-file "marker-positions.txt" (marker-positions-printer marker-positions))</example>
  <description>
   <p>
    A convenience function, based on `print-marker-positions', that, given a 
    list of marker-positions, gives a function with one argument, a port, that
    when applied writes the marker-positions to the port.
   </p>
   <p>
    The function is useful for calls to `call-with-output-file'.
   </p>
  </description>
 </method>

 <method name='marker-positions-port'>
  <brief>Convenience function for printing marker-positions.</brief>
  <prototype>(marker-positions-port port)</prototype>
  <example>(map (position-port port) list-of-marker-positions)</example>
  <description>
   <p>
    A convenience function, based on `print-marker-positions', that, given a 
    list a port, gives a function with one argument, a position, that
    when applied writes the marker-positions to the port.
   </p>
   <p>
    The function is useful for mapping over lists of marker-positions.
   </p>
  </description>
 </method>

 </module>



</guile-bindings>

