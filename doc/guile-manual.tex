\documentclass{manual}
\usepackage{url}

\title{CoaSim Guile Manual}
\subtitle{Using the Guile-based CoaSim Simulator}
\authors{Thomas Mailund}
\contact{mailund@birc.au.dk}
\company{Bioinformatics ApS}
\toolversion{CoaSim v4.0}



\begin{document}


\section{About This Manual}
\label{sec:about-this-manual}

CoaSim is a tool for simulating the coalescent process with
recombination and geneconversion, under either constant population
size or exponential population growth.  It effectively constructs the
ancestral recombination graph for a given number of chromosomes and
uses this to simulate samples of SNP and micro-satellite haplotypes or
genotypes.

CoaSim comes in two flavours: A graphical user interface version for
easy use by novice users, and a Guile Scheme
(\url{http://www.gnu.org/software/guile/}) based version for efficient
scripting.  This manual is about the Guile Scheme version and will
describe how to use CoaSim for various simulation purposes.  The
manual describes a number of common and more exotic simulation setups
and shows how CoaSim can be scripted to conduct such simulations.  The
manual has intentionally a bit of a tutorial flavour, as we wish to
give a feeling of the kind of simulations CoaSim is suited for, and
how such simulations are set up and executed in CoaSim, rather than
giving a detailed description of all the functions available in
CoaSim.  For the later, we refer to the \emph{CoaSim Scheme Bindings}
reference manual, distributed with CoaSim in
\url{/usr/local/share/coasim/doc/bindings.html}, or online at
\url{http://www.birc.dk/Software/CoaSim/refman/index.html}.

Some familiarity with the Scheme programming language and with
coalescent theory is assumed.  For people not familiar with Scheme, an
excellent tutorial can be found at
\url{http://www.ccs.neu.edu/home/dorai/t-y-scheme/t-y-scheme.html},
and for people not familiar with coalescent theory, the text book
\begin{quote}
  \textbf{Gene Genealogies, Variation and Evolution}\\
  \textit{A Primer in Coalescent Theory},\\
  Jotun Hein, Mikkel H.\ Schierup, and Carsten Wiuf,\\
  Oxford University Press, ISBN 0-19-852996-1  
\end{quote}
is recommended.

We also assume that you have successfully installed CoaSim, if not we
refer to the \emph{Getting Started with CoaSim} manual.


\subsection{Running CoaSim}
\label{sec:running-coasim}

The Guile-Scheme based CoaSim tool is run from the command line as:
\begin{code}
> coasim_guile file-1.scm file-2.scm ... file-n.scm
\end{code}
where each file is a scheme script; CoaSim will execute these script
files in turn, remembering the state between them, a feature that is
sometimes useful for setting up a set parameters in one file, and then
running simulations in following files.  In most cases, though, a
single file will suffice for running one or more simulations.  In the
rest of this manual we will assume that you know how to execute
scripts with CoaSim in this way, and concentrate on how to write the
appropriate scripts.

\section{Simple Sequence Simulations}
\label{sec:simple-sequ-simul}

We start out with the most common usage of CoaSim: simulating sequence
data.  All simulations in CoaSim result in an \emph{Ancestral
  Recombination Graph} (ARG), but in most cases the ARG is not the
desired end-result, rather, the sequences found at the leaves of the
ARG are.  To make the common case easy, CoaSim provides the function
\texttt{simulate-sequences}, that simulates an ARG and then
automatically extracts the sequences from the leaf-nodes.


\subsection{Simulating and Saving Sequences}
\label{sec:simul-saving-sequ}

A simple sequence simulation script could look like this:
\begin{code}
(use-modules (coasim rand))
(let* ((markers (make-random-snp-markers 10 0 1))
       (seqs (simulate-sequences markers 10)))
  (display seqs)(newline))
\end{code}

The first line
\begin{code}
(use-modules ((coasim rand))
\end{code}
includes the \texttt{(coasim rand)} module, which is used for
generating random markers (markers on random positions, in this case).
The random markers are then used in the next line of the script.  The
\verb?(let* ...)? construction is just a way of creating a block of
scheme code, that let us define variables.  The variables we define in
the code above are \texttt{markers}---containing 10 random SNP markers
with allowed mutant-frequencies between $0$ and $1$, created using the
\texttt{make-random-snp-markers} function---and \texttt{seqs}---the
simulated sequences.  There are 10 sequences, the second argument to
\texttt{simulate-sequences}, and each sequence contains an allele for
each marker in \texttt{markers}.

The sequences, as returned by \texttt{simulate-sequences}, are
represented as a list of lists of alleles.  This is a format that is
very easy to manipulate by Scheme, but not as useful for most other
programs, so printing the sequences in this format, as we do with the
\texttt{display} call above, is not that useful.  To print the
sequences in a more traditional form of a sequence per line, with the
sequences printed as space-separated numbers, we can use the
\texttt{(coasim io)} module like this:
\begin{code}
(use-modules (coasim rand) (coasim io))
(let* ((markers (make-random-snp-markers 10 0 1))
       (seqs (simulate-sequences markers 10)))
  (call-with-output-file "positions.txt" (marker-positions-printer markers))
  (call-with-output-file "sequences.txt" (sequences-printer seqs)))
\end{code}
Here, the positions are written to the file \texttt{positions.txt} and
the sequences to the file \texttt{sequences.txt}.  The
\texttt{call-with-output-file} function is a way of opening a file for
writing; it opens a file port, then calls it second argument with this
port, and then closes the port afterwards.  The
\texttt{marker-positions-printer} and \texttt{sequences-printer} take
care of writing the output.  They create functions that fit with the
interface of \texttt{call-with-output-file}, and that write the
positions and sequences, respectively, to the port opened by
the call to \texttt{call-with-output-file}.


\subsection{Simulation Parameters}
\label{sec:simul-param}

As called above, \texttt{simulate-sequences} simulate a basic
coalescent tree over the leaf nodes and then apply mutations on the
markers.  Recombinations, gene conversions and exponential growths can
be included by setting the appropriate parameters using keyword
arguments to \texttt{simulate-sequences}, e.g.\ to simulate with a
scaled recombination rate $\rho=4Nr=400$ (see \emph{Hein et al.}\ 
Sect.~5.5)---which for an effective population size of $N=10,000$
means that the region from $0$ to $1$ simulated correspond roughly to
$1cM$---you would need to call
\begin{code}
(simulate-sequences markers no-sequences \underline{:rho 400})
\end{code}

Similarly, to enable gene-conversions with rate $\gamma=4Ng$ and
intensity $Q=qL$ (see \emph{Hein et al.}\ Sect.~5.10), use the
keywords \texttt{:gamma} and \texttt{:Q} as in
\begin{code}
(simulate-sequences markers no-sequences \underline{:gamma 250 :Q 100})
\end{code}

%%and to use an exponential growth factor, $\beta=2Nb$, (see \emph{Hein
%%  et al.}\ Sect.~4.3), use the keyword \texttt{:beta} as in
%%\begin{code}
%%(simulate-sequences markers no-sequences \underline{:beta 100})
%%\end{code}

These parameters can be combined, so e.g.\ simulating sequences with both
gene conversions and recombination can be done using:
\begin{code}
(use-modules (coasim rand))
(let* ((markers (make-random-snp-markers 10 0 1))
       (seqs (simulate-sequences markers 10 \underline{:rho 400 :gamma 250 :Q 100})))
  (display seqs)(newline))
\end{code}


\subsection{Markers}
\label{sec:markers}

The first argument to the \texttt{simulate-sequences} function is a
list of markers.  All markers are positioned in the interval $0$--$1$
and to simulate different genetic distances you will have to scale the
simulation parameters above.  The list of markers passed to
\texttt{simulate-sequences} must be sorted with relation to the
position.  This is guaranteed to be the case when the list is created
using one of the random-marker functions from the \texttt{(coasim
  rand)} module, as in the case of \texttt{make-random-snp-markers}
above, but can otherwise be ensured by sorting the markers with the
\texttt{sort-markers} function from the \texttt{(coasim markers)}
module.

The markers determine how the sequences will be simulated, in the
sense that they position the polymorphism along the genomic region
being simulated---the relative distance between markers affects e.g.\ 
the probability of recombinations occurring between two markers---and
determine the model of mutations for the polymorphic sites.

So far, we have only used randomly distributed SNP markers, but we
need not only use SNP markers, nor need we stick to randomly
positioned markers.  CoaSim supports three types of markers, that
differs in how mutations are placed on the ARG.  The
built-in\footnote{Later in this manual we will see how to build our
  own custom marker types.} marker types are:
\begin{description}
\item[Trait markers] are binary polymorphisms (think presence or
  absence of a trait) with a simple mutation model: after simulating
  the ARG, a mutation is placed uniformly at random on the tree local
  to the marker position, nodes below the mutation will have the
  mutant allele while all others will have the wild-type allele.  A
  range of accepted mutant-frequencies can be specified and a simple
  rejection-sampling scheme is used to ensure it: if, after placing
  the mutation, the number of mutant leaves are not within the range,
  the ARG is rejected and the simulation restarted.
  
\item[SNP markers] resemble trait markers in that they are binary
  polymorphisms, and use the same mutation model as the trait-markers.
  The differer from the trait-markers in how the mutant-frequency is
  ensured: If, after the mutation has been placed, the number of
  mutant leaves does not fall within the accepted range, the mutation
  is re-placed, but the ARG is \texttt{not} rejected and
  re-simulated.  This places a bias on the markers, but one that
  resembles the ascertainment bias seen in association studies, where
  SNPs are chosen to have frequencies in certain ranges.
  
\item[Micro-satellite markers] are $k$-ary polymorphisms with a
  different mutation model than the other two.  For micro-satellite
  markers, each edge in the local tree at the marker is considered in
  turn, and based on a mutation rate and the length of the edge either
  a mutation is placed on the edge or it is not.  If it is, a randomly
  chosen allele from $0$ to $k-1$ is placed on the child node; if no
  mutation is placed, the child node gets a copy of the allele at the
  parent node.
\end{description}

A trait marker can be created using the function
\texttt{trait-marker}:
\begin{code}
(trait-marker position low-mutation-freq high-mutation-freq)
\end{code}
so e.g.\
\begin{code}
(trait-marker 0.5 0.18 0.22)
\end{code}
would place a trait marker at position $0.5$ with accepted
mutant-frequencies in the range $0.18$--$0.22$.  Quite similarly, SNP
markers can be created with the function \texttt{snp-marker}
\begin{code}
(snp-marker position low-mutation-freq high-mutation-freq)
\end{code}
while micro-satellite markers can be created with the function
\texttt{ms-marker}
\begin{code}
(ms-marker position \(\theta\) \(k\))
\end{code}
where $\theta$ is the scaled mutation rate $\theta=4N\mu$ and $k$ the
number of alleles permitted at the marker (i.e.\ the alleles on that
marker are numbered from $0$ to $k-1$ and each mutant allele is drawn
uniformly from this set).

Using these three functions we can explicitly create a list of markers
for a simulation:
\begin{code}
(let* ((markers (list (snp-marker   0.1  0.2  0.8)
                      (snp-marker   0.2  0.1  0.9)
                      (trait-marker 0.5  0.18 0.22)
                      (snp-marker   0.7  0.2  0.8)
                      (ms-marker    0.8  1.5  10)))
       (seqs (simulate-sequences markers 10 :rho 400)))
  (display seqs)(newline))
\end{code}

Here we create three SNP markers, on positions $0.1$, $0.2$ and $0.7$,
with mutation frequencies in the range $0.2$--$0.8$ for position
$0.1$ and $0.7$ and in the range $0.1$--$0.9$ for position $0.2$; a
single trait marker at position $0.5$, with mutation range
$0.18$--$0.22$, and a single micro-satellite marker at position $0.8$,
with mutation rate $1.5$ and with a pool of $10$ alleles.

Explicitly creating the markers in this way can be cumbersome, so
CoaSim provides functions for randomly generating markers, as we have
already seen, in the module \texttt{(coasim rand)}.  The three
functions:
\begin{code}
(make-random-trait-marker \(n\) low-freq high-freq)
(make-random-snp-marker   \(n\) low-freq high-freq)
(make-random-ms-marker    \(n\) \(\theta\) \(k\))
\end{code}
of which we have already used the second several times, creates $n$
markers, randomly positioned, of the respective marker types.

A list of markers created with these functions is guaranteed to be
sorted, but if you choose to combine several lists you must make sure
that the resulting list is sorted.  This can be done either by calling
\texttt{sort-markers} from the module \texttt{(coasim markers)} on the
combined list, or by combining the lists using the function
\texttt{merge-markers}, also from \texttt{(coasim markers)}, e.g.\
\begin{code}
(use-modules (coasim rand) (coasim markers))
(let* ((snp-markers   (make-random-snp-markers   10 0.1 0.9))
       (trait-markers (make-random-trait-markers  2 0.2 0.4))
       (unsorted-markers (append snp-markers trait-markers)))
  (sort-markers unsorted-markers))
\end{code}
creates a list, \texttt{unsorted-markers}, by appending two marker-lists
and then sort the markers using \texttt{sort-markers}, and is
equivalent to 
\begin{code}
(use-modules (coasim rand) (coasim markers))
(let* ((snp-markers   (make-random-snp-markers   10 0.1 0.9))
       (trait-markers (make-random-trait-markers  2 0.2 0.4)))
  (merge-markers snp-markers trait-markers))
\end{code}
that simply merges the two sorted lists.  Notice, however, that while
\texttt{sort-markers} will work on any list of markers,
\texttt{merge-markers} will only work on already sorted lists.

Another variation, that is sometimes useful, is to insert a marker at
the right position in a sorted list such that the resulting list is
sorted.  This can be done with the function \texttt{insert-sorted},
also from \texttt{(coasim markers)}:
\begin{code}
(insert-sorted sorted-marker-list marker)
\end{code}
the result is a list with all markers from \texttt{sorted-marker} and
the new marker, sorted.  As an example of this, consider the script:
\begin{code}
(use-modules (coasim rand) (coasim markers))
(let* ((snp-markers    (make-random-snp-markers   10 0.1 0.9))
       (disease-marker (trait-marker 0.5 0.2 0.4))
       (markers (insert-sorted snp-markers disease-marker))
       (seqs (simulate-sequences markers 10)))
  (display seqs)(newline))
\end{code}
Here we create $10$ randomly positioned SNP markers and a single trait
marker (here assumed to be a disease susceptibility gene) and place it
in the middle of the interval.  We then join the SNP markers with the
trait marker using \texttt{insert-sorted} and simulate 10 sequences
from these markers.


\subsection{Cases and Controls}
\label{sec:cases-controls}

Enough about markers, we will now return to the simulation of
sequences.  A common setting is simulating a set of sequences and then
split them into cases and controls based on a trait mutation.  We have
already seen how to create a trait marker, together with other
markers, and simulate a set of sequences over these markers; we have
not, however, considered how to split the sequences into cases and
controls, based on the allele on the trait marker.

The simplest way to do this is using the
\texttt{split-in-cases-controls-on-marker} function from module \texttt{(coasim
  SNP haplotypes)}.
\begin{code}
(split-in-cases-controls-on-marker sequence trait-idx)
\end{code}
which splits the sequence based on the alleles at an indexed marker.
Despite the module name, it is not actually restricted to sequences of
SNP haplotypes, but it does assume that the marker at index
\texttt{trait-idx} is a binary marker with $1$ denoting mutants and
$0$ wild-types.  Here, \texttt{trait-idx} is the index of the marker
to split on, indexing from $0$, in \texttt{sequences}.  The function
returns a list of two lists, the first being the mutants the second
the wild-types.  Both lists have the marker at \texttt{trait-idx}
removed, i.e.\ the contain one less marker than the input
sequence.\footnote{
  It is possible to disable the removal of the trait alleles in this
  function by calling the function with the key-word argument
  \texttt{:remove-trait} set to \texttt{\#f}.  In most cases, however,
  you do not want to keep the trait marker after having determined the
  case/control phenotype from it, so the default is to remove it.
  }

As an example, consider the following script:
\begin{code}
(use-modules (srfi srfi-1)) ; get the list-index function
(use-modules (coasim rand) (coasim markers) (coasim SNP haplotypes))
(let* ((snp-markers    (make-random-snp-markers 10 0.1 0.9))
       (disease-marker (trait-marker 0.5 0.2 0.4))
       (markers (insert-sorted snp-markers disease-marker))
       (disease-idx (list-index (lambda (m) (= 0.5 (position m))) markers))
       (seqs (simulate-sequences markers 10))
       (cases-controls (split-in-cases-controls-on-marker seqs disease-idx))
       (cases (car cases-controls))
       (controls (cadr cases-controls)))
  (display cases)(newline)(newline)
  (display controls)(newline)(newline))
\end{code}
Here we build a set of randomly placed SNP markers and a single trait
marker at the middle of the region, as earlier, and combine them using
\texttt{insert-sorted}.
\begin{code}
(use-modules (coasim rand) (coasim markers) (coasim SNP haplotypes))
(let* ((snp-markers    (make-random-snp-markers 10 0.1 0.9))
       (disease-marker (trait-marker 0.5 0.2 0.4))
       (markers (insert-sorted snp-markers disease-marker))
       ...)
  ...)
\end{code}
Since we need the index of the disease-marker, to be able to split the
sequences, we look that up using the \texttt{list-index} function from
the module \texttt{(srfi srfi-1)}:
\begin{code}
(use-modules (coasim rand) (coasim markers) (coasim SNP haplotypes))
(let* (...
       (disease-idx (list-index (lambda (m) (= 0.5 (position m))) markers))
       ...)
  ...)
\end{code}
and given this, we can simulate the sequences, split in cases and
controls using \texttt{split-in-cases-controls-on-marker} and get the cases as
the first element in the resulting list (or in Scheme the \texttt{car}
of the list) and the controls as the second element (in Scheme, the
\texttt{cadr} of the list):
\begin{code}
(use-modules (coasim rand) (coasim markers) (coasim SNP haplotypes))
(let* (...
       (seqs (simulate-sequences markers 10))
       (cases-controls (split-in-cases-controls-on-marker seqs disease-idx))
       (cases (car cases-controls))
       (controls (cadr cases-controls)))
  ...)
\end{code}

As an alternative to explicitly looking up the position of the trait
marker, you can also insert it into the SNP markers using the function
\texttt{insert-sorted-idx} from \texttt{(coasim markers)}; this
function works as \texttt{insert-sorted} but returns a list whose
\texttt{car} is the list of sorted markers, and whose \texttt{cadr} is
the index the new marker was inserted at.  We show the use of this in
the following script, where we also place the disease marker at a
random position and use the \texttt{(coasim io)} functions to write
the marker positions and the cases and controls sequences to files.
Changes from the previous script are underlined.
\begin{code}
(use-modules \underline{(coasim io)} (coasim rand)
             (coasim markers) (coasim SNP haplotypes))
(let* ((snp-markers    (make-random-snp-markers   10 0.1 0.9))
       (disease-marker \underline{(car (make-random-trait-markers 1 0.2 0.4))})
       \underline{(m-and-idx (insert-sorted-idx snp-markers disease-marker))}
       \underline{(markers (car m-and-idx))}
       \underline{(disease-idx (cadr m-and-idx))}
       (seqs (simulate-sequences markers 10))
       (cases-controls (split-in-cases-controls-on-marker seqs disease-idx))
       (cases (car cases-controls))
       (controls (cadr cases-controls)))
  \underline{(call-with-output-file "snp-positions.txt"}
  \underline{  (marker-positions-printer snp-markers))}
  \underline{(call-with-output-file "trait-position.txt" }
  \underline{  (marker-positions-printer (list disease-marker)))}
  \underline{(call-with-output-file "cases.txt"    (sequences-printer cases))}
  \underline{(call-with-output-file "controls.txt" (sequences-printer controls))})
\end{code}

Splitting the sequences into cases and controls based solely on the
allele at a trait marker is not always appropriate; when e.g.\ 
simulating a disease that is not completely penetrant, such as many
common diseases, we might wish to only select mutants with a certain
probability.  Similarly, when a disease is affected by environmental
factors as well as genetic factors, we might select wild-type
sequences as cases with a certain probability.  Both situations can be
handled with \texttt{split-in-cases-controls-on-marker} using the key-word
parameters \texttt{:mutant-prob} and \texttt{:wild-type-prob}, that
sets the probability of a mutant or wild-type, respectively, is
selected as a case.  To select about $20\%$ of mutants and only
$1\%$ of wild-types, for example, you would use:
\begin{code}
(split-in-cases-controls-on-marker seqs disease-idx
                                   \underline{:mutant-prob 0.2 :wild-type-prob 0.01})
\end{code}


\subsection{Running Multiple Simulations}
\label{sec:runn-mult-simul}

So far, we have only considered scripts for running a single
simulation, but running several simulations is not much more
complicated than running a single simulation.  Consider this variation
on the very first script we saw, with changes underlined:
\begin{code}
(use-modules \underline{(coasim batch)} (coasim rand))
\underline{(repeat 10}
   (let* ((markers (make-random-snp-markers 10 0 1))
          (seqs (simulate-sequences markers 10)))
     (display seqs)(newline))\underline{)}
\end{code}

In this version, we load the module \texttt{(coasim batch)} which
gives us access to the function \texttt{repeat} that let us run a
script a fixed number of times, in this case $10$.

When we are just printing the results of a simulation, as above, the
\texttt{repeat} function is simple and easy to use, but if we want to
save the results in various files we want to be able to use different
files for each simulation.  One way of doing this is to have a counter
that is incremented with each iteration, and use this counter to
create new file names for each simulation.  Using the function
\texttt{repeat-with-index}, also from \texttt{(coasim batch)}, this
could look like:
\begin{code}
(use-modules (coasim rand) (coasim io) (coasim batch))
(repeat-with-index (i 1 10)
   (let* ((markers (make-random-snp-markers 10 0 1))
          (seqs (simulate-sequences markers 10))
          (pos-file (string-append "positions." (number->string i) ".txt"))
          (seq-file (string-append "sequences." (number->string i) ".txt")))
     (call-with-output-file pos-file (marker-positions-printer markers))
     (call-with-output-file seq-file (sequences-printer seqs))))
\end{code}
Here the variable \texttt{i} iterates from $1$ to $10$, and for each
value a list of markers and sequences are generated and written to
files \texttt{positions.}$i$\texttt{.txt} and
\texttt{sequences.}$i$\texttt{.txt}, respectively.

We will return to \texttt{(coasim batch)} again later in this manual,
for constructing more complex scripts, but for now we will once again
consider running a single simulation per script.


\subsection{Unphased Genotype Sequences}
\label{sec:unph-genotype-sequ}

CoaSim simulates haplotype sequences, but we can combine these to
genotype data by pairing sequences.  For SNP data, this can be done
using the function \texttt{haplotypes->genotypes} from module
\texttt{(coasim SNP genotypes)}:
\begin{code}
(use-modules (coasim rand) (coasim SNP genotypes))
(let* ((haplotypes
          (simulate-sequences (make-random-snp-markers 2 0.1 0.2) 100))
       (genotypes \underline{(haplotypes->genotypes haplotypes)}))
  (display genotypes)(newline))
\end{code}

Using \texttt{haplotypes->genotypes}, an even number of haplotype
sequences are translated into genotype sequences by combining
sequences two and two, translating pairs of alleles by mapping
$00\mapsto 0$, $11\mapsto 1$, $01\mapsto 2$, and $10\mapsto 2$.

Genotype sequences can also be split in cases and controls using the
function \texttt{split-in-cases-controls-on-marker}, this time from the module
\texttt{(coasim SNP genotypes)} rather than \texttt{(coasim SNP haplotypes)}:
\begin{code}
(use-modules (coasim rand) (coasim SNP genotypes))
(let* ((haplotypes
          (simulate-sequences (make-random-snp-markers 2 0.1 0.2) 100))
       (genotypes (haplotypes->genotypes haplotypes))
       \underline{(cases-controls (split-in-cases-controls-on-marker genotypes 1))}
       (cases (car cases-controls))
       (controls (cadr cases-controls)))
  (display cases)(newline)
  (display controls)(newline)
  (newline))
\end{code}

By default, \texttt{split-in-cases-controls-on-marker} selects
homozygote mutant sequences as cases, homozygote wild-type sequences
as controls, and heterozygote as cases with probability $0.5$ and
controls with probability $0.5$.  This default can be changed using
keyword arguments \texttt{:homozygote-0-prob}, setting the probability
of a homozygote $00$ being a case, \texttt{:homozygote-1-prob},
setting the probability of a homozygote $11$ being a case, and
\texttt{:heterozygote-prob}, setting the probability of a heterozygote
$01$ being a case.  E.g.\ to select as cases homozygote mutants with
probability $0.5$, heterozygotes with probability $0.1$ and homozygote
wild-types with probability $0.01$, we would use:
\begin{code}
(split-in-cases-controls-on-marker genotypes idx 
                                   \underline{:homozygote-1-prob 0.5}
                                   \underline{:heterozygote-prob 0.1}
                                   \underline{:homozygote-0-prob 0.01})
\end{code}

As a short-cut for setting common probabilities, we can use the
keyword argument \texttt{:disease-model}.  Setting the disease model
to \texttt{'dominant}:
\begin{code}
(split-in-cases-controls-on-marker genotypes \underline{:disease-model} '\underline{dominant})
\end{code}
will set the probability for both homozygote mutants and heterozygotes
being cases to $1$ and the probability for homozygote wild-types being
cases to $0$, while setting the disease model to \texttt{'recessive}
\begin{code}
(split-in-cases-controls-on-marker genotypes \underline{:disease-model} '\underline{recessive})
\end{code}
will set the probability of homozygote mutants being cases to $1$ and
the probability of the other two genotypes being cases to $0$.



\section{Population Structure}
\label{sec:pop-structure}

In the simulations we have seen so far, we have simulated samples from
a single, constant size, population, but CoaSim contains a powerful
specification language for demographic structures.  Instead of using
the form for simulating sequences we have used so far
\begin{code}
(simulate-sequences markers no-sequences ...)
\end{code}
we use the more general form
\begin{code}
(simulate-sequences markers population-structure ...)
\end{code}
where \texttt{population-structure} is a program describing the
population structure of the sample.


\subsection{Bottlenecks and Exponential Growth}
\label{sec:b-and-eg}



FIXME

\subsection{Sub-populations}
\label{sec:sub-pop}

FIXME

\subsection{Migration}
\label{sec:migration}

FIXME


%% FIXME: update beta's below


\section{Simulating the ARG and (Local) Coalescent Trees}
\label{sec:simul-coal-trees}

Until now we have only considered simulating sequences, but CoaSim
actually simulates a full ARG when it is simulating the sequences, and
it is possible to access it and extract information about it.  In
fact, the \texttt{simulate-sequences} function is actually a wrapper
function doing exactly that:
\begin{code}
(define (simulate-sequences . params)
  (sequences (apply simulate params)))
\end{code}
It builds the ARG by calling the \texttt{simulate} function (by
applying\footnote{The \texttt{apply} function is a way of
  calling a function with a list of parameters, contained in an actual
  list rather than provided directly to the function.  Thus
  \texttt{(apply f '(a b c))} is equivalent to \texttt{(f a b c)}.} it
to the arguments passed to it) and then extracts the sequences from
the leaves in the ARG using the function \texttt{sequences}.  The
general function to use---for obtaining other simulation results than
the sequences---is \texttt{simulate}; a call to \texttt{simulate} will
return an ARG from which various results can be extracted.  Since the
function \texttt{simulate-sequences} is just a wrapper that calls
\texttt{simulate} with the parameters it gets, 
\texttt{simulate} takes the same simulation parameters as
\texttt{simulate-sequences}.

There is one slight complication though: since simulating sequences is
by far the most common use of CoaSim, it has been optimised for this.
This optimisation includes discarding the history of ancestral
material intervals not containing any of the markers specified in the
simulation parameters.  This reduces the memory usage considerably,
and speeds up the simulations a bit, but also means that the complete
ARG is not available after the simulation is completed.  In many cases
this is not a problem, but if the full ARG is needed after the
simulation the optimisation can be turned off by using the keyword
argument \texttt{:keep-empty-intervals} set to \texttt{\#t}:

\begin{code}
(define ARG (simulate \emph{parameters} :keep-empty-intervals \#t))
\end{code}

This is usually recommended when you wish to explore the genealogy
between the specified markers---or when you are not interested in
markers and only wish to simulate ARGs---but is not needed for e.g.\
simulating the local coalescent trees at the specified markers.


\subsection{Simulating the ARG}
\label{sec:simulating-arg}

As a simple example, we can try simulating an ARG and then extract
some statistics from it.  We will use three functions for
extracting statistics, all from the \texttt{(coasim statistics)} module:
\begin{itemize}
\item \texttt{no-coalescence-events}---returns the number of
  coalescence events that occurred in simulating the ARG.
\item \texttt{no-gene-conversions}---returns the number of gene
  conversions that occurred in simulating the ARG.
\item \texttt{no-recombinations}---returns the number of
  recombinations that occurred in simulating the ARG.
\end{itemize}

Using these could look like this:
\begin{code}
(use-modules ((coasim statistics) :select (no-coalescence-events
                                           no-gene-conversions
                                           no-recombinations))
             ((ice-9 format) :select (format)))
(let ((ARG (simulate '() 10
                     :rho 40 :gamma 60 :Q 10
                     :keep-empty-intervals \#t)))
  (format #t "#recomb: ~d, #gene conv.: ~d, #coalescent: ~d\(\backslash\)n"
          (no-recombinations     ARG)
          (no-gene-conversions   ARG)
          (no-coalescence-events ARG)))  
\end{code}
Here we simulate an ARG and print the number of recombination events,
gene conversions and coalescence events.  Notice that we do not
provide any markers to \texttt{simulate}---the marker list is the
empty list \texttt{'()}---but we instead turn off the empty intervals
optimisation using \texttt{:keep-empty-intervals}.

We have also introduced one additional new thing in this example: the
\texttt{format} function.  This function is actually not CoaSim
specific, but part of the general Guile library module \texttt{(ice-9
  format)}; it is a convenient way of formatting output, similar to
\texttt{printf} from C.  The first parameter is a port, if the
formatted output should be written to that port, \texttt{\#f} if the
formatted output is to be returned as a string, or \texttt{\#t}---as
in the example above---if the output should be output to the current
output port, standard out.  The second argument is a string describing
the output, and the following are values to be formatted.  The types
and number of these, and the way of formatting them, is determined by
the formatting string.  For learning more about \texttt{format}, we
refer to the Guile documentation.

As another example, we can try to extract the local intervals of the
ARG, that is, the intervals of the ARG not broken up by a
recombination event.  To get the list of these intervals, we use the
function \texttt{intervals}, as below:
\begin{code}
(let* ((ARG (simulate '() 10 :rho 40 :keep-empty-intervals #t))
       (inter (intervals ARG))
       ...)
    ...)
\end{code}
Again, we need to turn off the empty intervals optimisation, since
otherwise we would only get the intervals containing markers; in this
case no interval will contain a marker since we have provided no
markers to the \texttt{simulate} function.

From the list of intervals, we could, for instance, calculate the
average interval length.  To do this we use functions
\texttt{interval-start} and \texttt{interval-end} to get the start
point and end point of the interval, respectively, and the obtain the
length by subtracting the start point from the end point
\begin{code}
(let* ((ARG (simulate '() 10 :rho 40 :keep-empty-intervals #t))
       (inter (intervals ARG))
       \underline{(len (lambda (i) (- (interval-end i) (interval-start i))))}
       \underline{(interval-lengths (map len inter))}
       ...)
    ...)
\end{code}
add the resulting lengths---here by applying function \texttt{+} to
the length list---and then dividing by the number of intervals:
\begin{code}
(let* ((ARG (simulate '() 10 :rho 40 :keep-empty-intervals #t))
       (inter (intervals ARG))
       (len (lambda (i) (- (interval-end i) (interval-start i))))
       (interval-lengths (map len inter))
       \underline{(mean (/ (apply + interval-lengths) (length interval-lengths))))}
  (display mean)(newline))
\end{code}


\subsection{Simulating Trees}
\label{sec:simulating-trees}

Using functions \texttt{interval->tree} and \texttt{tree->interval},
we can switch back and forth between local intervals and the
coalescence tree for that interval.  So to get all the local
coalescence trees in the ARG, we can map \texttt{interval->tree} over
the list of intervals, or alternatively use the function
\texttt{local-trees} which does exactly this:
\begin{code}
(define (local-trees ARG) (map interval->tree (intervals ARG)))
\end{code}

To simulate a single coalescence tree, we can use code like this:
\begin{code}
(let* ((ARG (simulate '() 10 :keep-empty-intervals #t))
       (tree (car (local-trees ARG))))
  (display tree))
\end{code}
We simulate the ARG and then extract the list of local trees.  This
will only contain a single tree, since we are simulating without
recombination---we have not set the \texttt{:rho} parameter, which
means that it defaults to $0$---and we take this single tree out of
the list and display it.  Displaying a tree this way will print out
the tree in Newick format.

If we add recombination to the simulation, we could also be interested
in knowing the extend of the interval for which the tree is the
genealogy.  We can get this interval together with the tree like this:
\begin{code}
(let* ((m (snp-marker 0.5 0 1))
       (ARG (simulate (list m) 10 :rho 40))
       (i (car (intervals ARG)))
       (t (interval->tree i)))
  (display (interval-start i))(display "-")
  (display (interval-end i))(display ": ")
  (display t))
\end{code}
Here we use a single marker, at the centre of the genomic region---a
SNP marker that will accept any minor allele frequency ($0.0$--$1.0$), which
essentially means that we do not care about the alleles at the marker;
it is the local tree for this marker, and the interval for this tree,
that we extract from the simulation.

We simulate \texttt{with} the empty intervals optimisation, which
guarantees that only intervals containing markers will be returned by
the \texttt{intervals} function---in this example it guarantees that
\texttt{intervals} only return the one interval we are interested
in---extract the interval and the corresponding local tree---using the
\texttt{interval->tree} function---and then display the extracted
information.

Using the function \texttt{tree-height} we can get the hight of the
tree, and for example compute the average height along the genomic
sequence:
\begin{code}
(let* ((ARG (simulate '() 10 :rho 40 :beta 10 :keep-empty-intervals #t))
       (trees (local-trees ARG))
       (tree-heights (map tree-height trees))
       (mean (/ (apply + tree-heights) (length tree-heights))))
  (display mean)(newline))
\end{code}
or the mean height over a number of simulations
\begin{code}
(use-modules ((coasim batch) :select (tabulate)))
(let* ((no-iterations 10000)
       (tree-heights
        (tabulate no-iterations
                  (let* ((ARG (simulate '() 10
                                        :beta 10
                                        :keep-empty-intervals #t))
                         (tree (car (local-trees ARG))))
                    (tree-height tree)))))
  (display (/ (apply + tree-heights) no-iterations))(newline))
\end{code}

In the last example we use the \texttt{tabulate} function described
earlier to run a number of iterations and collect the result in a
list.  We simulate with exponential growth ($\beta=10$); without
growth we have a closed form for the mean tree
height---$E(H_n)=2\left(1-\frac{1}{n}\right)$, see \emph{Hein et al.}
Sect.~1.9---but for $\beta>0$ we it makes sense to use simulations to
get the expected tree height.  In the first example, we simulated with
recombination ($\rho=40$) to get a number of intervals; in the second
example we do not allow recombination ($\rho$ is implicitly $0$) since
we only extract a single local tree any way.

Using the function \texttt{total-branch-length}, we can get the sum of
branch lengths of the tree, and we can calculate the mean of those for
varying $\beta$ just as for tree heights as above.


\subsection{Exploring the ARG}
\label{sec:exploring-arg}

Aside from the functions mentioned above, for extracting information
about the ARG, it is possible to extract information from the ARG by
explicitly traversing it and extracting the information through
custom-made functions.  Since we rarely have to explicitly traverse
the ARG---most interesting simulation results can be extracted using
other methods---we will not go into details about this general
traversal, but just give short pointers to the relevant functions.

The key functions for traversing the ARG are \texttt{root}---which
returns the root node of a tree, or the \emph{Most Recent Common
  Ancestor} (MRCA) of an interval---and \texttt{children}---which
returns a list of the children of a node; this will be two children
nodes for coalescence nodes, one child node for recombination and
gene-conversions nodes, and an empty list for leaf nodes.

It is possible to check the type of nodes using the predicates
\texttt{coalescent-node?}, \texttt{gene-conversion-node?},
\texttt{leaf-node?}, and \texttt{recombination-node?} and through
these tread the different nodes differently during a traversal.  Three
additional functions can be used for extracting information about a
node:
\begin{itemize}
\item \texttt{event-time}---returns the time the node was created (in
  scaled coalescence time, $2N$), and
\item \texttt{ancestral?}---predicate that determines if the
  ancestral material in the node contains a given point.
\item \texttt{trapped?}---predicate that determines if the
  a point is trapped between ancestral material in a node.
\end{itemize}

To accumulate information about \texttt{all} the ARG nodes, it is
usually more convenient to use the \texttt{fold-nodes} function than
to explicitly traverse the nodes using \texttt{root} and
\texttt{children}.  The function \texttt{fold-nodes} takes as
parameters, in addition to the ARG, a function taking two parameters,
and an initial value for the accumulation.  The function is called,
for each node in the ARG, with the node and the value accumulated so
far, initially the value passed to \texttt{fold-nodes}.  As an
example, to count the total number of nodes in the ARG, we can use:
\begin{code}
(fold-nodes ARG (lambda (n count) (+ count 1)) 0)
\end{code}
or to count the total number of coalescence nodes:
\begin{code}
(fold-nodes ARG 
            (lambda (n count) 
               (if (coalescent-node? n) (+ count 1) count)) 
            0)
\end{code}





\section{Advanced Usage}
\label{sec:advanced-usage}

In this section we give a few examples of more advanced usage of
CoaSim.  This should by no mean be considered an exhaustive list of
the possibilities for CoaSim simulations, but only give a taste of the
possibilities that are available when programming scripts for the
simulator.  Through the functions described in the reference manual,
CoaSim is highly programmable, and very flexible in the kinds of
simulations it can run.


\subsection{Scaling Parameters}
\label{sec:scaling-parameters}

If we wish to run simulations under various growth parameters, but the
same effective recombination rate---and mutation rate in case of
micro-satellites---we need to scale $\rho$ and $\theta$ for $\beta>0$
such that e.g.\ 
$\rho_{\beta=0}\cdot{}E(L_{n,\beta=0})=\rho_\beta\cdot{}E(L_{n,\beta})$,
where $\rho_\beta$ and$\rho_{\beta=0}$ are the recombination rates
with and without growth, respectively, and $E(L_{n,\beta})$ and
$E(L_{n,\beta=0})$ are the expected total branch lengths with and
without growth, respectively, see \emph{Hein et al.} Sect.~1.9.

For $E(L_{n,\beta=0})$ we have a formula:
\begin{equation}
  \label{eq:1}
  E(L_{n,\beta=0})=2\sum_{j=1}^{n-1}\frac{1}{j}
\end{equation}
but for $E(L_{n,\beta})$ we need to calculate the average total branch
lengths over a number of simulations.  Given the simulated expected
value, we can then rescale $\rho$ and $\theta$ accordingly: 
\[\rho_\beta=\rho_{\beta=0}\cdot\frac{E(L_{n,\beta=0})}{E(L_{n,\beta})}
  \quad\quad\quad
  \theta_\beta=\theta_{\beta=0}\cdot\frac{E(L_{n,\beta=0})}{E(L_{n,\beta})}
\]

In CoaSim, we can calculate the rescaling like this:
\begin{code}
(use-modules (coasim batch))
(define no-leaves    20)

(define (calc-scale-factor beta)
  (if (= beta 0) 1 ; no need to simulate this one...
      (let ((zero-growth-tree-length
             ;; calculating the tree length without growth from closed
             ;; term formula
             (let loop ((j 1) (sum 0))
               (if (< j no-leaves)
                   (loop (+ j 1) (+ sum (/ 1 j)))
                   sum)))
            (growth-tree-length
             ;; simulating the tree length with growth
             (let* ((no-iterations 10000)
                    (branch-sum
                     (fold no-iterations (lambda (val sum) (+ val sum)) 0
                           (let* ((ARG (simulate '() no-leaves :beta beta
                                                 :keep-empty-intervals #t))
                                  (tree (car (local-trees ARG))))
                             (total-branch-length tree)))))
               (/ branch-sum no-iterations))))
        (/ zero-growth-tree-length growth-tree-length))))

(define (scaled-simulate beta rho theta)
  (let* ((scale-factor   (calc-scale-factor beta))
         (scaled-rho     (* scale-factor rho))
         (scaled-theta   (* scale-factor theta))
         ...)
    ...))
\end{code}
Here we calculate $E(L_{n,\beta=0})$ using~(\ref{eq:1}) and simulate
$E(L_{n,\beta})$ by calculating the average branch length over
$10,000$ iterations.  To calculate the average length, we use the
function \texttt{fold} from module \texttt{(coasim batch)}, which
works similar to the function \texttt{fold-nodes} we saw earlier;
given a number of iterations, \texttt{no-iterations}, a function for
accumulating results 
\begin{code}
  (lambda (val sum) (+ val sum))
\end{code}
an initial value, $0$, and a piece of code for producing the results,
we can accumulate results from a number of iterations.

If we run many simulations with the same $\beta$, the solution above
will be inefficient since we re-calculate the scale factor each time,
but it is easy to build a preprocessed table of scale factors and use
that:
\begin{code}
(define (calc-scale-factor beta)
  (if (= beta 0) \underline{(cons 0 1)} ; no need to simulate this one...
      (let ((zero-growth-tree-length
              ...))
        \underline{(cons beta} (/ zero-growth-tree-length growth-tree-length)))))

(define betas '(0 10 100))
(define scale-factors (map calc-scale-factor betas))

(define (scaled-simulate beta rho theta)
  (let* ((scale-factor   (assoc-ref scale-factors beta))
         (scaled-rho     (* scale-factor rho))
         (scaled-theta   (* scale-factor theta))
         ...)
    ...))
\end{code}
Here we change \texttt{calc-scale-factor} to return pairs of $\beta$
and the corresponding scale factor, from which we build an association
list---a list of pairs that can be thought of as a mapping form the
first elements in the pairs to the second elements---and we look up
the scale factors in this association list using the built-in function
\texttt{assoc-ref}.
  

\subsection{Rejection Sampling}
\label{sec:rejection-sampling}

There are three hooks for callbacks in the simulations:
\begin{itemize}
\item \texttt{:coalescence-callback}---called with the single node
  that is the result of a coalescent event, and the number of lineages
  at the time of the coalescent (i.e.\ the number of linages just after
  the event, moving forward in time).
\item \texttt{:recombination-callback}---called with the two nodes
  that is the result of a recombination event, and the number of
  lineages at the time of the recombination (i.e.\ the number of
  linages just after the event, moving forward in time).
\item \texttt{:geneconversion-callback}---called with the two nodes
  that is the result of a gene conversion event, and the number of
  lineages at the time of the gene conversion (i.e.\ the number of
  linages just after the event, moving forward in time).
\end{itemize}
These are called during the ARG simulation, whenever one of the
respective events happens.  They can be used to gather information
from the simulation---although the same information can be obtained by
traversing the ARG after the simulation---but also used for aborting a
running simulation in a rejection sampling setup.

Say we want to simulate $10,000$ coalescent trees simulated under
recombination rate $\rho=2$, but conditional on no recombination in
fact did happen.  We could, of course, simulate ARGs till completion
and reject ARGs containing recombination nodes, but it is much more
efficient to abort the simulation once the first recombination occurs.

To reject a simulation when the first recombination event occurs, we
can install a callback for recombination events that just throws an
exception.  We can then wrap the simulation in a function that tries
to perform the simulation, and if the exception is throw just restarts
with another try:
\begin{code}
(define (try-simulate)
  ;; keep trying to simulate until a simulation is NOT aborted
  (let* ((reject-recomb (lambda (n1 n2 k) (throw 'reject)))
         (try (lambda ()
                ;; simulate an ARG, but reject the simulation if a
                ;; recombination occurred
                (simulate '() 10 :rho 2
                          :recombination-callback reject-recomb
                          :keep-empty-intervals   #t)))
         (except (lambda (ex-key . ex-args) #f)))
    (let ((res (catch 'reject try except)))
      (if res res (try-simulate)))))
\end{code}
Here we use the callback \texttt{reject-recomb} to throw the exception
\texttt{'reject} when a recombination occurs---since
\texttt{reject-recomb} is installed as the recombination callback
through the \texttt{:recombination-callback} keyword parameter.  The
function \texttt{try} runs a simulation and returns the ARG if the
simulation is not rejected, and the exception handler \texttt{except}
reports a rejection by returning \texttt{\#f}.  We then evaluate the
whole thing using the \texttt{catch} function, that wraps the try and
exception handling, and retry if the result was \texttt{\#f} rather
than an ARG.\footnote{The reason that we cannot simply try again in
  the exception handler---which would be the obvious way of doing
  this---is that we need \texttt{try-simulate} to be tail-recursive to
  avoid stack overflows if many simulations are rejected.}

By using \texttt{try-simulate} we are guaranteed to only obtain ARGs
without recombinations, despite the recombination rate $\rho=5$, and
we can run our $10,000$ simulations to, say, extract the average tree
height, using a loop:
\begin{code}
(let ((sum-of-heights
       (let loop ((n 0) (sum 0))
         (if (= n 10000) sum ; done
             (let* ((ARG (try-simulate))
                    (h   (tree-height (car (local-trees ARG)))))
               (loop (+ n 1) (+ sum h)))))))
  (display (/ sum-of-heights 10000))
  (newline))
\end{code}
or using \texttt{fold} from \texttt{(coasim batch)} again:
\begin{code}
(use-modules (coasim batch))
(let ((sum-of-heights
       (fold 10000 (lambda (val sum) (+ val sum)) 0
             (tree-height (car (local-trees (try-simulate)))))))
  (display (/ sum-of-heights 10000))
  (newline))
\end{code}


\subsection{Variable Recombination Rate}
\label{sec:vari-recomb-rate}

In all examples so far, we have used a constant recombination rate,
$\rho$, over the region we simulate.  We can think of this as working
with a genetic distance rather than physical distance between loci on
the region; the distance between two markers is linearly proportional
to the expected recombinations between them.

It is well known that the rate of recombination varies across the
genome, so if we simulate markers placed on a `physical distance'
region, we no longer expect a linear relationship between distance and
recombination.  We can, however, simulate variable recombination rates
simply by scaling the physical distance into genetic distance and
simulate with the scaled markers.

If we split the (physical distance) interval $0-1$ into segments, with
each segment getting a different recombination rate, we can rescale
the interval $0-1$ by making the length of each segment proportional
to the original length of the segment times the recombination rate of
the segment.  Let $l_i$ be the length of segment $i$ and $r_i$ the
rate of segment $i$, and let $bp_i=\sum_{j<i}l_i$.  Then,
for any locus $x$: $bp_i \leq x < bp_{i+1}$, we can rescale $x$ to
\[x' = \frac{r_i\cdot{}(x-bp_i) + \sum_{j<i}l_j\cdot{}r_j}
            {\sum_{j}l_j\cdot{}r_j}.
\]

The locus is scaled according to the total scaled range of the
previous segments, from $0$ to $bp_i$, by adding
$\sum_{j<i}l_j\cdot{}r_j$, and then the expected recombination in the
current segment, $r_i\cdot(x-bp_i)$.  The scaled loci should all be
moved to the interval $0-1$ for CoaSim to be able to handle them, thus
the final scaling constant, $1/\sum_{j}l_j\cdot{}r_j$.


The function \texttt{rescale-markers!} from module \texttt{(coasim
  markers)} preforms exactly this rescaling.  It takes a list of
markers and a list of recombination rates covering the interval $0-1$,
and scales the markers positions.  The list of recombination rates is
a list of the form 
\begin{code}
{((length-1 rate-1) (length-2 rate-2) ... (length-n rate-n))}
\end{code}
where the lengths must sum to $1$.  This list
provides the $l_i$s and $r_i$s above.  The list of markers, which must
be sorted wrt. their position, provides the $x$s above and are
rescaled.

For example, to give the third quarter of the interval $0-1$ a
recombination rate ten times as high as the rest of the interval, we
could use
\begin{code}
(define recomb-rates '((0.5 1) (0.25 10) (0.25 1)))
(rescale-markers! markers recomb-rates)
\end{code}

The actual value of the rates in this list is not so important, only
the relative rates: all loci are scaled down to the interval $0-1$ as
described above, and the total recombination on this interval is
determined by the $\rho$ parameter given to the simulate function.
The actual recombination rate of a segment with length $l$ and rate
$r$ would be $\rho\cdot\frac{r\cdot{}l}{\sum_jr_j\cdot{}l_j}$, thus
for the third quarter of $0-1$ to have recombination rate $400$ ($1cM$
assuming the effective population size is $10,000$) we should simulate
with $\rho=\frac{400\cdot{}(0.5\cdot{}1+0.25\cdot{}10+0.25\cdot{}1)}
                {0.25\cdot{}10}=
520$.  On the other hand, to let the entire interval have
recombination rate $\rho=400$, the first half would be scaled to rate
$400\cdot{}\frac{0.5\cdot{}1}{3.5}=57.14$, the third quarter would be
scaled to rate $400\cdot{}\frac{0.25\cdot{}10}{3.5}=285.71$, and the
final quarter would be scaled to rate
$400\cdot{}\frac{0.25\cdot{}1}{3.5}=28.57$.


\subsection{Writing Custom Markers}
\label{sec:writ-cust-mark}

We have seen the three types of built-in markers supported by CoaSim
earlier, but it is also possible to define new marker types yourself.
To create a custom marker, you call the function
\texttt{custom-marker} with a position, an ancestral allele value (or
a function for creating it, if the ancestral allele should be random),
and a function for handling mutations:
\begin{code}
(custom-marker pos allele-value mutate)
\end{code}
The ancestral allele value, \texttt{allele-value}, should either be an
integer, or a function taking no arguments and returning an integer
value.  The \texttt{mutate} function is called with three parameters
for each edge in the ARG: the parent node of the edge, the child node
of the edge, and the parent allele of the edge.  It is then responsible
for returning the allele for the child; this will be the same as for
the parent if no mutation occurs on the edge.

Below is shown how the \texttt{custom-marker} function can be used to
define a step-wise mutation model for micro-satellite markers.  Here,
the initial allele value is always set to 0 and the whole piece of
code is an implementation of the mutation model.  The \texttt{mutate}
function uses two helper functions, one for selecting the waiting time
for the next mutation, and one for, conditional on a mutation
occurring, mutating an allele into another.  Waiting times are
selected from an exponential distribution, and \texttt{mutate}
iteratively selects waiting times and apply mutations until the next
waiting time moves past the length of the edge being processed.

\begin{code}
(define (step-ms-marker pos theta)
  (let* ((msec (cdr (gettimeofday)))
         (random-state (seed->random-state msec))

         (waiting-time
          ;; waiting time for next mutation
          (lambda ()
            (let ((mean (/ 2 theta)));mean is 1/i where the
                                     ;intensity i is theta/2
              (* mean (random:exp random-state)))))

         (mutate-to
          ;; randomly mutating up or down
          (lambda (parent-allele)
            (if (< (random 1.0 random-state) 0.5)
                (- parent-allele 1)
                (+ parent-allele 1))))

         (mutate
          ;; mutation function to use in the custom marker
          (lambda (parent child parent-allele)
            (let loop ((allele parent-allele)
                       (time-left 
                        (- (- (event-time parent) (event-time child))
                           (waiting-time))))
              (if (< time-left 0)
                  allele
                  (let ((new-allele (mutate-to allele))
                        (next-time (waiting-time)))
                    (loop new-allele (- time-left next-time))))))))

    (custom-marker pos 0 mutate)))
\end{code}


\section{Customising CoaSim}
\label{sec:customising-coasim}

CoaSim is highly programmable---as we have seen in the later parts of
this manual---and at some point you might wish to extend it with a few
of your own custom functions.  You can, of course, include those
functions in the various simulation scripts you write, but it is more
convenient to keep the general functions in a single copy---to avoid
the inevitable problems with redundancy---and just have them available
for use in the simulation scripts.


\subsection{Start-up File}
\label{sec:start-up-file}

Upon start-up, CoaSim checks if the file \url{~/.coasim/startup.scm}
exists, and if so, loads it in and execute it before any other script
is run.  Since any code in this file will be executed before any
scripts, it is an ideal place to put your custom functions if you want
them to be available to all scripts.  As \url{~/.coasim/startup.scm}
is \texttt{always} executed, it can hurt runtime performance to put
time-consuming computations here, so that is best avoided.


\subsection{Local Modules}
\label{sec:local-modules}

The CoaSim Scheme modules we have used in this manual---the modules on
the form \texttt{(coasim \emph{module-name})}---are globally installed
together with CoaSim, but it is also possible to install modules
locally.  Before searching globally for a module---using a path that
depends on the platform, but is most often
\url{/usr/local/share/coasim/scheme}---it searches in the directory
\url{~/.coasim/}; by placing a module in this directory you can
include it in your scripts using \texttt{use-modules}.

For example, to create a module, \texttt{(stepwise)}, containing the
step-wise mutation model micro-satellite described earlier, we can
save the code
\begin{code}
(define-module (stepwise))

(define-public (step-ms-marker pos theta)
  (let* ((msec (cdr (gettimeofday)))
  ;; ... same as before ...
\end{code}
in the file \url{~/.coasim/stepwise.scm}.  The \texttt{define-module}
in the beginning of the file informs the scheme interpreter that this
really is a module, with the right name, and the
\texttt{define-public}, rather than just \texttt{define}, exports the
function from the module to the script including the module.  This
module can now be included in your scripts, similarly to the globally
installed modules, by the \texttt{use-modules} function:
\begin{code}
(use-modules (stepwise))
\end{code}


\section{Contact}
\label{sec:contact}

For any comments or questions regarding CoaSim, please contact the
author, Thomas Mailund, at \url{<mailund@mailund.dk>} or
\url{<mailund@birc.au.dk>}.


\end{document}

%% Local Variables: ***
%% TeX-command-default:"LaTeX PDF" ***
%% End: ***

% LocalWords:   CoaSim geneconversion haplotype haplotypes SNP
