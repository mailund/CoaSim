\documentclass{manual}

\title{Getting Started with CoaSim/Guile}
\subtitle{An introduction to the simulator CoaSim}
\authors{Thomas Mailund}
\contact{mailund@birc.au.dk}
\company{Bioinformatics ApS}
\toolversion{CoaSim/Guile v4.1}

\usepackage{wrapfig}

\begin{document}

\section{About CoaSim}

CoaSim is a tool for simulating the coalescent process with
recombination and geneconversion, under either constant population
size or exponential population growth.  It effectively constructs the
ancestral recombination graph for a given number of chromosomes and
uses this to simulate samples of SNP and micro-satellite haplotypes or
genotypes.

CoaSim comes in two flavours: A graphical user interface version for
easy use by novice users, and a script based version (using either
Guile-Scheme or Python) for efficient batch simulations.  This
document is an introduction to the Guile-Scheme based version.

\subsection{Installing CoaSim}

CoaSim is distributed as RPM files or as source code.  For most users,
we recommend installing from the RPM files, since building the tool
from source requires setting up the right build environment and having
access to the needed development tools.  If you are not familiar with
UNIX C++ development---using the Automake suite of tools---we do not
recommend that you try building from source.

\paragraph{Installing the RPM Files.}

The RPM file, \verb?coasim-guile-x.y.z-r.i386.rpm?, contains a binary
version of the program, compiled to an Intel x86 Linux platform.  To
install the Scheme version, run
\begin{code}
> rpm -Uvh coasim-guile-x.y.z-r.i386.rpm
\end{code}
Since the RPM files installs in the directory \verb?/usr/local/?,
installing the RPM package requires root access.

\paragraph{Installing from the Source Files.}

The source code is distributed in a tar-file:
\verb?coasim-guile-x.y.z.tar.gz?.  To build the Guile version from
the source files untar the file, build the Core module
\begin{code}
> tar zxf coasim-guile-x.y.z.tar.gz
> cd coasim-guile-version/Core
> ./configure
> make
\end{code}
and then build the Guile module:
\begin{code}
> cd ../Guile
> ./configure
> make
\end{code}


\subsection{Running CoaSim}

The scheme based version is started from the command-line; the
parameters for the simulation or simulations to be run is described in
one or more configuration scripts, which are written in the Scheme
programming language, see the \textit{CoaSim Scheme} manual for
documentation.  Starting CoaSim with a configuration script
\verb?simulation.scm?---for example---is done as:
\begin{code}
> coasim_guile simulation.scm
\end{code}
Run \verb?coasim_guile --help? to get a complete list of command-line
options accepted by CoaSim.

\section{Using CoaSim}

Running CoaSim will in most cases consist of three steps: Set up the
simulation parameters, including the markers (type of marker, mutation
rates and similar), demographic parameters, rates for recombination,
etc.; running the simulation obtaining and ARG; and extracting the
needed information from the ARG (\emph{Ancestral Recombination
  Graph}), e.g. the resulting sequences, the timing of the various
events, or the local coalescent trees embedded in the ARG.

Before using the Guile-Scheme based CoaSim \emph{it is necessary that
  you have installed the program}, not just compiled the program; at
least if you are using any of the scheme modules distributed with
CoaSim.  If the tool has not been properly installed, it will not be
able to locate the modules and the scripts, including several of the
included test scripts, will not be able to run.  If it is not possible
to install the modules globally, you can install the locally but you
will then need to set the \verb?GUILE_LOAD_PATH? environment variable
to let CoaSim know where the modules are installed.  Consult the Guile
manual for further details
(\verb?http://www.gnu.org/software/guile/docs/?).

Once CoaSim is successfully installed, it can be run with any number
of files as argument:
\begin{code}
> coasim_guile file-1.scm file-2.scm ... file-n.scm
\end{code}
CoaSim will execute these files as scheme programs in turn,
remembering the state between them, a feature that is sometimes useful
for setting up a set parameters in one file, and then running
simulations in following files.  In most cases, though, a single file
will suffice for running one or more simulations.

Controlling the simulations through scheme makes CoaSim a very
flexible and powerful simulation tool. However, with flexibility
inevitably is associated some complexity, and while running simple
simulations through the scheme interface is quite simple, the more
complex simulation tasks require a bit of knowledge about the Scheme
programming language and the scheme modules supplied with CoaSim.  To
keep this `getting started' guide short, we do not attempt to explain
the scheme interface to CoaSim in detail here---for this we refer to
the \emph{CoaSim Guile Manual}---instead we give a short introduction
to running very simple simulations, and give an overview of the
example scripts distributed with CoaSim.

A very simple use of CoaSim is to simulate coalescent trees.  A script
for that is shown here:
\begin{code}
(let* ((m (snp-marker 0.5 0 1))
       (arg (simulate (list m) 10))
       (tree (car (local-trees arg))))
  (display tree))
\end{code}
This might look a bit complicated, but if you break it down in the
three phases mentioned at the beginning of this section---setting up
parameters, running a simulation, and analysing the result---it is
really not.

The \verb?(let* ...)? construction is just a way of creating a block
of scheme code, that lets us define variables.  The variables we
define in the code above are \texttt{m}, \texttt{arg}, and
\texttt{tree}.  The variable \texttt{m} is part of the first phase,
setting up parameters.  In fact, it is the only part of this phase.
The expression
\begin{code}
(let* ((m (snp-marker 0.5 0 1))
       ...)
  )
\end{code}
defines \texttt{m} to be a SNP marker, positions at the middle of the
genomic region we consider (position 0.5), with the 0-allele frequency
to be between 0 and 1, i.e. unrestricted.

The next line is the simulation phase, it defines the variable
\texttt{arg} to hold the ARG that is the result of the simulation.
\begin{code}
(let* (...
       (arg (simulate (list m) 10))
       ...)
  )
\end{code}

The first parameter of the simulation is a list of markers---in this
case just the single marker \texttt{m} from above.  The second
argument is the number of chromosomes to simulate, in this case 10.

Once the ARG is simulated, we can start the analysis phase; in this
example it is very simple: we simply print the coalescent tree.  We
obtain the tree by taking the first local tree from the ARG
(recombinations will split the genomic region into intervals with
different trees, but in this example will only get a single tree, so
the tree we are interested in is the first and only local tree).
Selecting this tree is done with
\begin{code}
(let* (...
       (tree (car (local-trees arg))))
  )
\end{code}
where \texttt{local-trees} extracts the list of local trees from the
ARG, and \texttt{car} (which is scheme-speak for the head of a list)
selects the first tree in the list.  The final statement in the script:
\begin{code}
(let* (...)
  (display tree))
\end{code}
simply prints the tree.


As another simple application, consider simulating a list of SNP
sequences.  A script for simulating 100 sequences with 10 SNP markers
in each is shown here:
\begin{code}
(use-modules ((coasim rand)))
(let* ((markers (make-random-snp-markers 10 0 1))
       (seqs (simulate-sequences markers 10 :rho 400)))
  (display seqs)(newline))
\end{code}

The first line
\begin{code}
(use-modules ((coasim rand))
\end{code}
includes the \texttt{(coasim rand)} module, which is used for
generating random markers (markers on random positions, in this case).

The following lines are similar to the script above
\begin{code}
(let* ((markers (make-random-snp-markers 10 0 1))
       (seqs (simulate-sequences markers 10 :rho 400)))
  (display seqs)(newline))
\end{code}
except that we now make a list of 10 markers, using a function from
the module we just included, \texttt{make-random-snp-markers},
simulate a set of sequences rather than the ARG, and with 100 rather
than 10 chromosomes, and with the recombination rate $\rho$ set to 400
(which for an effective population size $N_e$ of 10,000 roughly
correspond to 1cM).  Actually, the \texttt{simulate-sequences}
function is just a short-cut for an ARG simulation using
\texttt{simulate}, as before, and a function, \texttt{sequences}, for
extracting the sequences from an ARG.  The following script is thus
equivalent to the script above:
\begin{code}
(let* ((markers (make-random-snp-markers 10 0 1))
       (arg (simulate markers 10 :rho 400))
       (seqs (sequences arg)))
  (display seqs)(newline))
\end{code}
A script very similar to the tree simulation script.

Printing sequences with the \texttt{display} function will print a
list of lists; this is a format that is very simple for Scheme to read
and manipulate, but is usually not suitable for other analysis tools.
To print the sequences in a more traditional form of a sequence per
line, with the sequences printed as space-separated numbers, we can
use the \texttt{(coasim io)} module like this:
\begin{code}
(use-modules ((coasim rand)) (coasim io))
(let* ((markers (make-random-snp-markers 10 0 1))
       (seqs (simulate-sequences markers 10 :rho 400)))
  (call-with-output-file "positions.txt" 
    (marker-positions-printer markers))
  (call-with-output-file "sequences.txt"     
    (sequences-printer seqs)))
\end{code}
Here, the positions are written to the file \texttt{positions.txt} and
the sequences to the file \texttt{sequences.txt}.  The
\texttt{call-with-output-file} function is a way of opening a file for
writing and the \texttt{marker-positions-printer} and
\texttt{sequences-printer} take care of writing the output.

Running several simulations is not much more complicated than running
a single simulation.  Consider the following script that simulates 10
coalescent trees instead of only one:
\begin{code}
(use-modules ((coasim batch) :select (repeat)))
(repeat 10 (let* ((m (snp-marker 0.5 0 1))
                  (arg (simulate (list m) 10))
                  (tree (car (local-trees arg))))
             (display tree)))
\end{code}

The first line loads a module---just as we loaded the module
\texttt{(coasim rand)} above---but with a slight variation that only
loads a single function, \texttt{repeat}, and not the entire module.
In most cases you would just load the module, but we only load
\texttt{repeat} here to give an example of how this is done.  Loading
single functions from a module, instead of the entire module, can be
useful to avoid name-clashing in your scripts.

The next statement calls \texttt{repeat} with two arguments, the
number of simulations to run, and the code for the simulation; the
latter you will recognise as the same code we used above to simulate a
single tree.

When conducting a large number of simulations, it is usually not
desirable to print all results, but rather to calculate some
statistics about the simulations.  As a very simple example, instead
of printing simulated trees, we can calculate the mean of the total
branch length of the trees.  For this we again use the module
\texttt{(coasim batch)}, but rather than using \texttt{repeat} we use
the function \texttt{tabulate} that lets us collect simulation
results.  The complete script looks like this:
\begin{code}
(use-modules ((coasim batch) :select (tabulate)))
(let* ((no-iterations 10000)
       (branch-lengths
        (tabulate no-iterations
                  (let* ((m (snp-marker 0.5 0 1))
                         (arg (simulate (list m) 10))
                         (tree (car (local-trees arg))))
                    (total-branch-length tree)))))
  (display (/ (apply + branch-lengths) no-iterations))(newline))
\end{code}

We fix the number of simulations to use and give it the name
\texttt{no-iterations}, using the \texttt{(let* ...)} syntax, we then
call \texttt{tabulate} with the number of iterations and the code for
simulating a tree and getting its branch length.  The main difference
in the simulation code is that we call the function
\texttt{total-branch-length} on the tree instead of printing it using
\texttt{display}.

The result of the \texttt{tabulate} call is a list of simulation
results, which we store in the variable \texttt{branch-lengths}.  We
then use this list to calculate the mean by summing the values (using
the function call \texttt{(apply + branch-lengths)} and dividing it
with the number of iterations \texttt{(/ ... no-iterations)}, and we
finally print the result using \texttt{display}.


Calculating the branch-length like this is a bit silly, since we can
calculate the expected branch length for a coalescent tree with $n$
nodes simply as
\[
  2\sum_{i=1}^{n-1}\frac{1}{i}
\]
but when we add exponential growth, no such simple formula exists.  As
a final example of running simulations in CoaSim, consider calculating
the mean branch length for various growth parameters $\beta$:

\begin{code}
(use-modules ((coasim batch) :select (tabulate)))

(define betas '(0 10 20))
(define (mean-branch-length beta)
  (let* ((no-iterations 1000)
         (branch-lengths
          (tabulate no-iterations
            (let ((arg (simulate (list (snp-marker 0.5 0 1)) 10 :beta beta)))
              (total-branch-length (car (local-trees arg)))))))
    (/ (apply + branch-lengths) no-iterations)))

(display (map mean-branch-length betas))(newline)
\end{code}

This looks very similar to the simulation code above, but we have now
defined a list of $\beta$ values:
\begin{code}
(define betas '(0 10 20))
\end{code}
and made the mean branch lengths calculation into a function of $\beta$:
\begin{code}
(define (mean-branch-length beta)
    ...)
\end{code}

The way that $\beta$ is specified to the simulation is through the
keyword argument \texttt{:beta value} in
\begin{code}
    (simulate (list (snp-marker 0.5 0 1)) 10 :beta beta)
\end{code}

The final line in the script `maps' the \texttt{mean-branch-length}
function over the $\beta$ values, which means that it applies the
function on each $\beta$ and collect the results in a list, and it
then prints this list using \texttt{display}.

Calculating the mean branch length in this way is inefficient, since
we build a list of all simulated values and then sum the elements; it
would be more efficient to calculate the sum during the iterations.
This can also be done, using the \texttt{fold} function rather than
\texttt{tabulate}:

\begin{code}
(use-modules ((coasim batch) :select (fold)))

(define betas '(0 10 20))
(define (mean-branch-length beta)
  (let* ((no-iterations 10)
         (branch-sum
          (fold no-iterations (lambda (val sum) (+ val sum)) 0
                (let* ((m (snp-marker 0.5 0 1))
                       (arg (simulate (list m) 10 :beta beta))
                       (tree (car (local-trees arg)))
                       (branch-length (total-branch-length tree)))
                  branch-length))))
    (/ branch-sum no-iterations)))

(display (map mean-branch-length betas))(newline)
\end{code}

The \texttt{fold} method, which will be familiar to people with
exposure to functional programming, builds a value from the
simulations using a function for combining the result so far with the
latest simulated value, and an initial value.  In the example above,
the function
\begin{code}
     (lambda (val sum) (+ val sum))
\end{code}
adds a new value to the sum so far, with the initial value 0.  Folding
with this pair of combination function and initial value lets us
calculate the sum of branch lengths without building a list of the
simulated values.


For further examples, see \verb?/usr/local/share/coasim/test-input/?
containing the files (in order of increasing complexity):
\begin{itemize}
\item \texttt{tree.scm}---the tree example from above.
\item \texttt{interval-and-tree.scm}---simulation of a tree and it's
  local interval under recombination.
\item \texttt{sequences.scm}---the sequence example from above.
\item \texttt{arg-statistics.scm}---extracting the number of different
  kinds of events from a simulation.
\item \texttt{mean-interval-length.scm}---calculates the mean length
  of local intervals for an ARG.
\item \texttt{mean-tree-height-1.scm}---calculate the mean height of
  trees along the genomic region.
\item \texttt{mean-tree-height-2.scm}---calculate the mean height of
  trees over multiple simulations.
\item \texttt{snp-haplotype.scm}---a more detailed example of
  simulating SNP sequences.
\item \texttt{snp-haplotype-split.scm}---an example of
  simulating SNP sequences and splitting them into cases and controls,
  based on a trait-marker.
\item \texttt{more-trees.scm}---the simulation and printing of several
  trees, from above.
\item \texttt{more-sequences.scm}---simulation of several sequences,
  writing them to different files.
\item \texttt{mean-branch-length.scm}---the calculation of the mean branch
  length of trees, from above.
\item \texttt{more-mean-branch-length.scm}---the calculation of the mean branch
  length of trees with various $\beta$ values, from above.
\item \texttt{fold-mean-branch-length.scm}---the calculation of the mean branch
  length of trees with various $\beta$ values using \texttt{fold}, as
  above.
\item \texttt{scaling.scm}---rescaling $\rho$ and $\theta$ according
  to simulated average branch lengths.
\item \texttt{ms.scm}---an example of simulating sequences and
  outputting them in Hudson's ms format.
\item \texttt{rejection-sampling.scm}---example of using callbacks to
  do rejection sampling.
\end{itemize}

\section{Contact}
\label{sec:contact}

For any comments or questions regarding CoaSim, please contact Thomas
Mailund, at \href{mailto:mailund@mailund.dk}{mailund@mailund.dk} or
\href{mailund@birc.au.dk}{mailund@birc.au.dk}.


\end{document}

% LocalWords:   CoaSim geneconversion haplotype haplotypes
